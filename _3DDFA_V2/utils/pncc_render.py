# coding: utf-8

__author__ = 'cleardusk'

import sys

sys.path.append('..')

import cv2
import numpy as np
import os.path as osp

from Sim3DR import rasterize, rasterize_adv, get_image_color
from _3DDFA_V2.utils.functions import plot_image
from _3DDFA_V2.utils.io import _load, _dump
from _3DDFA_V2.utils.tddfa_util import _to_ctype

make_abs_path = lambda fn: osp.join(osp.dirname(osp.realpath(__file__)), fn)


from Sim3DR import rasterize
from _3DDFA_V2.utils.functions import plot_image
from _3DDFA_V2.utils.io import _load
from _3DDFA_V2.utils.tddfa_util import _to_ctype

make_abs_path = lambda fn: osp.join(osp.dirname(osp.realpath(__file__)), fn)






def bilinear_interpolate(img, x, y):
    """
    https://stackoverflow.com/questions/12729228/simple-efficient-bilinear-interpolation-of-images-in-numpy-and-python
    """
    x0 = np.floor(x).astype(np.int32)
    x1 = x0 + 1
    y0 = np.floor(y).astype(np.int32)
    y1 = y0 + 1

    x0 = np.clip(x0, 0, img.shape[1] - 1)
    x1 = np.clip(x1, 0, img.shape[1] - 1)
    y0 = np.clip(y0, 0, img.shape[0] - 1)
    y1 = np.clip(y1, 0, img.shape[0] - 1)

    i_a = img[y0, x0]
    i_b = img[y1, x0]
    i_c = img[y0, x1]
    i_d = img[y1, x1]

    wa = (x1 - x) * (y1 - y)
    wb = (x1 - x) * (y - y0)
    wc = (x - x0) * (y1 - y)
    wd = (x - x0) * (y - y0)

    return wa[..., np.newaxis] * i_a + wb[..., np.newaxis] * i_b + wc[..., np.newaxis] * i_c + wd[..., np.newaxis] * i_d


def calc_ncc_code():
    from bfm import bfm

    # formula: ncc_d = ( u_d - min(u_d) ) / ( max(u_d) - min(u_d) ), d = {r, g, b}
    u = bfm.u
    u = u.reshape(3, -1, order='F')

    for i in range(3):
        u[i] = (u[i] - u[i].min()) / (u[i].max() - u[i].min())

    _dump('../configs/ncc_code.npy', u)




def get_img_color(img, ver_lst, tri, ncc_code, with_bg_flag=True):



    for ver_ in ver_lst:
        ver = _to_ctype(ver_.T)  # transpose

        ncc_code = bilinear_interpolate(img, ver[:, 0], ver[:, 1]) / 255.

        #
        # # (3, 38365) ncc_code
        # _, _, ref_triangles, buffer = get_image_color(ver, tri, ncc_code, bg=overlap, alpha=1.0)  # m x 3
        # buffer = buffer - 0.1
        # # print(np.sum(ref_triangles<0))
        # # print(ver[:,2])
        # # ref_triangles = 76073
        # # used_area = 112 112 3
        # # ncc_code 3 x 38365
        # # ver = 38365 x 3
        #
        # ncc_code, used_area, ref_triangles, buffer = get_image_color(ver, tri, ncc_code, bg=overlap, alpha=1.0,
        #                                                           buffer=buffer)  # m x 3
        # for i,r in enumerate(ref_triangles):
        #     if r>0:
        #         ncc_code[tri[i,0],:]=ncc_code[tri[r-1,0],:]
        #         # ncc_code[tri[i,1],:]=ncc_code[tri[r-1,0],:]
        #         # ncc_code[tri[i,2],:]=ncc_code[tri[r-1,0],:]

    return ncc_code
    #
    # for ver_ in ver_lst:
    #     ver = _to_ctype(ver_.T)  # transpose
    #     ncc_code = _to_ctype( ncc_code.T)  # transpose
    #
    #     #(3, 38365) ncc_code
    #     _, _,ref_triangles,buffer= rasterize_adv(ver, tri, ncc_code, bg=img, alpha=1.0)  # m x 3
    #     buffer=buffer-0.1
    #     # print(np.sum(ref_triangles<0))
    #     # print(ver[:,2])
    #     overlap, used_area,ref_triangles,buffer= rasterize_adv(ver, tri, ncc_code, bg=img, alpha=1.0,buffer=buffer)  # m x 3
    # return overlap

def main():
    # `configs/ncc_code.npy` is generated by `calc_nnc_code` function
    # calc_ncc_code()
    pass


if __name__ == '__main__':
    main()
